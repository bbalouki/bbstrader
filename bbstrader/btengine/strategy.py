from abc import ABCMeta, abstractmethod
import pytz
import pandas as pd
import numpy as np
from queue import Queue
from datetime import datetime
from bbstrader.config import config_logger
from bbstrader.btengine.event import SignalEvent
from bbstrader.btengine.event import FillEvent
from bbstrader.btengine.data import DataHandler
from bbstrader.metatrader.account import Account
from bbstrader.metatrader.rates import Rates
from typing import (
    Dict,
    Union,
    Any,
    List,
    Literal
)
from bbstrader.models.optimization import optimized_weights

__all__ = ['Strategy', 'MT5Strategy']

class Strategy(metaclass=ABCMeta):
    """
    A `Strategy()` object encapsulates all calculation on market data 
    that generate advisory signals to a `Portfolio` object. Thus all of 
    the "strategy logic" resides within this class. We opted to separate 
    out the `Strategy` and `Portfolio` objects for this backtester, 
    since we believe this is more amenable to the situation of multiple 
    strategies feeding "ideas" to a larger `Portfolio`, which then can handle 
    its own risk (such as sector allocation, leverage). In higher frequency trading, 
    the strategy and portfolio concepts will be tightly coupled and extremely 
    hardware dependent.

    At this stage in the event-driven backtester development there is no concept of 
    an indicator or filter, such as those found in technical trading. These are also 
    good candidates for creating a class hierarchy.

    The strategy hierarchy is relatively simple as it consists of an abstract 
    base class with a single pure virtual method for generating `SignalEvent` objects. 
    Other methods are provided to check for pending orders, update trades from fills,
    and get updates from the portfolio.
    """

    @abstractmethod
    def calculate_signals(self, *args, **kwargs) -> Any:
        raise NotImplementedError(
            "Should implement calculate_signals()"
        )
    def check_pending_orders(self, *args, **kwargs): ...
    def get_update_from_portfolio(self, *args, **kwargs): ...
    def update_trades_from_fill(self, *args, **kwargs): ...


class MT5Strategy(Strategy):
    """
    A `MT5Strategy()` object is a subclass of `Strategy` that is used to 
    calculate signals for the MetaTrader 5 trading platform. The signals
    are generated by the `MT5Strategy` object and sent to the the `MT5ExecutionEngine`
    for live trading and `MT5BacktestEngine` objects for backtesting.
    """

    def __init__(self, events: Queue=None, symbol_list: List[str]=None,
                 bars: DataHandler=None, mode: str=None, **kwargs):
        """
        Initialize the `MT5Strategy` object.

        Args:
            events : The event queue.
            symbol_list : The list of symbols for the strategy.
            bars : The data handler object.
            mode : The mode of operation for the strategy (backtest or live).
            **kwargs : Additional keyword arguments for other classes (e.g, Portfolio, ExecutionHandler).
                - max_trades : The maximum number of trades allowed per symbol.
                - time_frame : The time frame for the strategy.
                - logger : The logger object for the strategy.
        """
        self.events = events
        self.data = bars
        self.symbols = symbol_list
        self.mode = mode
        self._porfolio_value = None
        self.risk_budget = self._check_risk_budget(**kwargs)
        self.max_trades = kwargs.get("max_trades", {s: 1 for s in self.symbols})
        self.tf = kwargs.get("time_frame", 'D1')
        self.logger = kwargs.get("logger")
        self._initialize_portfolio()
        self.kwargs = kwargs

    @property
    def cash(self) -> float:
        return self._porfolio_value
    
    @cash.setter
    def cash(self, value):
        self._porfolio_value = value

    @property
    def orders(self) -> Dict[str, Dict[str, List[SignalEvent]]]:
        return self._orders
    
    @property
    def trades(self) -> Dict[str, Dict[str, int]]:
        return self._trades

    @property
    def positions(self) -> Dict[str, Dict[str, int|float]]:
        return self._positions
    
    @property
    def holdings(self) -> Dict[str,  float]:
        return self._holdings
    
    def _check_risk_budget(self, **kwargs):
        weights = kwargs.get('risk_weights')
        if weights is not None and isinstance(weights, dict):
            for asset in self.symbols:
                if asset not in weights:
                    raise ValueError(f"Risk budget for asset {asset} is missing.")
            total_risk = sum(weights.values())
            if not np.isclose(total_risk, 1.0):
                raise ValueError(f'Risk budget weights must sum to 1. got {total_risk}')
            return weights
        elif isinstance(weights, str):
            return weights

    def _initialize_portfolio(self):
        positions = ['LONG', 'SHORT']
        orders = ['BLMT', 'BSTP', 'BSTPLMT', 'SLMT', 'SSTP', 'SSTPLMT']
        self._positions: Dict[str, Dict[str, int | float]] = {}
        self._trades: Dict[str, Dict[str, int]] = {}
        self._orders: Dict[str, Dict[str, List[SignalEvent]]] = {}
        for symbol in self.symbols:
            self._positions[symbol] = {}
            self._orders[symbol] = {}
            self._trades[symbol] = {}
            for position in positions:
                self._trades[symbol][position] = 0
                self._positions[symbol][position] = 0.0
            for order in orders:
                self._orders[symbol][order] = []
        self._holdings = {s: 0.0 for s in self.symbols}
        
    def get_update_from_portfolio(self, positions, holdings):
        """
        Update the positions and holdings for the strategy from the portfolio.

        Positions are the number of shares of a security that are owned in long or short.
        Holdings are the value (postions * price) of the security that are owned in long or short.

        Args:
            positions : The positions for the symbols in the strategy.
            holdings : The holdings for the symbols in the strategy.
        """
        for symbol in self.symbols:
            if symbol in positions:
                if positions[symbol] > 0:
                    self._positions[symbol]['LONG'] = positions[symbol]
                elif positions[symbol] < 0:
                    self._positions[symbol]['SHORT'] = positions[symbol]
                else:
                    self._positions[symbol]['LONG'] = 0
                    self._positions[symbol]['SHORT'] = 0
            if symbol in holdings:
                self._holdings[symbol] = holdings[symbol]
    
    def update_trades_from_fill(self, event: FillEvent):
        """
        This method updates the trades for the strategy based on the fill event.
        It is used to keep track of the number of trades executed for each order.
        """
        if event.type == 'FILL':
            if event.order != 'EXIT':
                self._trades[event.symbol][event.order] += 1
            elif event.order == 'EXIT' and event.direction == 'BUY':
                self._trades[event.symbol]['SHORT'] = 0
            elif event.order == 'EXIT' and event.direction == 'SELL':
                self._trades[event.symbol]['LONG'] = 0

    def calculate_signals(self, *args, **kwargs
                          ) -> Dict[str, Union[str, dict, None]] | None:
        """
        Provides the mechanisms to calculate signals for the strategy.
        This methods should return a dictionary of symbols and their respective signals.
        The returned signals should be either string or dictionary objects.

        If a string is used, it should be:
        - ``LONG`` , ``BMKT``, ``BLMT``, ``BSTP``, ``BSTPLMT`` for a long signal (market, limit, stop, stop-limit).
        - ``SHORT``, ``SMKT``, ``SLMT``, ``SSTP``, ``SSTPLMT`` for a short signal (market, limit, stop, stop-limit).
        - ``EXIT``, ``EXIT_LONG``, ``EXIT_LONG_STOP``, ``EXIT_LONG_LIMIT``, ``EXIT_LONG_STOP_LIMIT`` for an exit signal (long).
        - ``EXIT_SHORT``, ``EXIT_SHORT_STOP``, ``EXIT_SHORT_LIMIT``, ``EXIT_SHORT_STOP_LIMIT`` for an exit signal (short).
        - ``EXIT_ALL_ORDERS`` for cancelling all orders.
        - ``EXIT_ALL_POSITIONS`` for exiting all positions.
        - ``EXIT_PROFITABLES`` for exiting all profitable positions.
        - ``EXIT_LOSINGS`` for exiting all losing positions.

        The signals could also be ``EXIT_STOP``, ``EXIT_LIMIT``, ``EXIT_STOP_LIMIT`` for exiting a position.

        If a dictionary is used, it should be:
        for each symbol, a dictionary with the following keys
        - ``action``: The action to take for the symbol (LONG, SHORT, EXIT, etc.)
        - ``price``: The price at which to execute the action.
        - ``stoplimit``: The stop-limit price for STOP-LIMIT orders.
        - ``id``: The unique identifier for the strategy or order.

        The dictionary can be use for pending orders (limit, stop, stop-limit) where the price is required
        or for executing orders where the each order has a unique identifier.
        """
        pass

    def apply_risk_management(self, optimer, symbols=None, freq=252) -> Dict[str, float] | None:
        """
        Apply risk management rules to the strategy.
        """
        if optimer is None:
            return None
        symbols = symbols or self.symbols
        prices = self.get_asset_values(
            symbol_list=symbols, bars=self.data, mode=self.mode, 
            window=freq, value_type='close', array=False, tf=self.tf
        )
        prices = pd.DataFrame(prices)
        prices = prices.dropna(axis=0, how='any')
        try:
            weights = optimized_weights(prices=prices, freq=freq, method=optimer)
            return {symbol: weight for symbol, weight in weights.items()}
        except Exception:
            return {symbol: 0.0 for symbol in symbols}

    def get_quantity(self, symbol, weight,   price=None, volume=None, maxqty=None) -> int:
        """
        Calculate the quantity to buy or sell for a given symbol based on the dollar value provided.
        The quantity calculated can be used to evalute a strategy's performance for each symbol
        given the fact that the dollar value is the same for all symbols.

        Args:
            symbol : The symbol for the trade.

        Returns:
            qty : The quantity to buy or sell for the symbol.
        """
        if (self._porfolio_value is None or weight == 0 or
            self._porfolio_value == 0 or np.isnan(self._porfolio_value)):
            return 0
        if volume is None:
            volume = round(self._porfolio_value * weight)
        if price is None:
            price = self.data.get_latest_bar_value(symbol, 'close')
        if (price is None or not isinstance(price, (int, float, np.number))
            or volume is None or not isinstance(volume, (int, float, np.number)) 
            or np.isnan(float(price))
            or np.isnan(float(volume))
        ):
            if weight != 0:
                return 1
            return 0
        qty = round(volume / price, 2)
        qty = max(qty, 0) / self.max_trades[symbol]
        if maxqty is not None:
            qty = min(qty, maxqty)
        return max(round(qty, 2), 0)
    
    def get_quantities(self, quantities: Union[None, dict, int]) -> dict:
        """
        Get the quantities to buy or sell for the symbols in the strategy.
        This method is used when whe need to assign different quantities to the symbols.

        Args:
            quantities : The quantities for the symbols in the strategy.
        """
        if quantities is None:
            return {symbol: None for symbol in self.symbols}
        if isinstance(quantities, dict):
            return quantities
        elif isinstance(quantities, int):
            return {symbol: quantities for symbol in self.symbols}
    
    def _send_order(self, id,  symbol: str, signal: str, strength: float, price: float,
                    quantity: int, dtime: datetime | pd.Timestamp):

        position = SignalEvent(id, symbol, dtime, signal,
                               quantity=quantity, strength=strength, price=price)
        log = False
        if signal in ['LONG', 'SHORT']:
            if self._trades[symbol][signal] < self.max_trades[symbol] and quantity > 0:
                self.events.put(position)
                log = True
        elif signal == 'EXIT':
            if self._positions[symbol]['LONG'] > 0 or self._positions[symbol]['SHORT'] < 0:
                self.events.put(position)
                log = True
        if log:
            self.logger.info(
                f"{signal} ORDER EXECUTED: SYMBOL={symbol}, QUANTITY={quantity}, PRICE @{price}", custom_time=dtime)

    def buy_mkt(self, id: int, symbol: str, price: float, quantity: int, 
            strength: float=1.0, dtime: datetime | pd.Timestamp=None):
        """
        Open a long position

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        self._send_order(id, symbol, 'LONG', strength, price, quantity, dtime)

    def sell_mkt(self, id, symbol, price, quantity, strength=1.0, dtime=None):
        """
        Open a short position

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        self._send_order(id, symbol, 'SHORT', strength,  price, quantity, dtime)

    def close_positions(self, id, symbol, price, quantity, strength=1.0, dtime=None):
        """
        Close a position or exit all positions

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        self._send_order(id, symbol, 'EXIT', strength, price, quantity, dtime)

    def buy_stop(self, id, symbol, price, quantity, strength=1.0, dtime=None):
        """
        Open a pending order to buy at a stop price

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        current_price = self.data.get_latest_bar_value(symbol, 'close')
        if price <= current_price:
            raise ValueError(
                "The buy_stop price must be greater than the current price.")
        order = SignalEvent(id, symbol, dtime, 'LONG',
                            quantity=quantity, strength=strength, price=price)
        self._orders[symbol]['BSTP'].append(order)

    def sell_stop(self, id, symbol, price, quantity, strength=1.0, dtime=None):
        """
        Open a pending order to sell at a stop price

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        current_price = self.data.get_latest_bar_value(symbol, 'close')
        if price >= current_price:
            raise ValueError(
                "The sell_stop price must be less than the current price.")
        order = SignalEvent(id, symbol, dtime, 'SHORT',
                            quantity=quantity, strength=strength, price=price)
        self._orders[symbol]['SSTP'].append(order)

    def buy_limit(self, id, symbol, price, quantity, strength=1.0, dtime=None):
        """
        Open a pending order to buy at a limit price

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        current_price = self.data.get_latest_bar_value(symbol, 'close')
        if price >= current_price:
            raise ValueError(
                "The buy_limit price must be less than the current price.")
        order = SignalEvent(id, symbol, dtime, 'LONG',
                            quantity=quantity, strength=strength, price=price)
        self._orders[symbol]['BLMT'].append(order)

    def sell_limit(self, id, symbol, price, quantity, strength=1.0, dtime=None):
        """
        Open a pending order to sell at a limit price

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        current_price = self.data.get_latest_bar_value(symbol, 'close')
        if price <= current_price:
            raise ValueError(
                "The sell_limit price must be greater than the current price.")
        order = SignalEvent(id, symbol, dtime, 'SHORT',
                            quantity=quantity, strength=strength, price=price)
        self._orders[symbol]['SLMT'].append(order)

    def buy_stop_limit(self, id: int, symbol: str, price: float, stoplimit: float, 
                       quantity: int, strength: float=1.0, dtime: datetime | pd.Timestamp = None):
        """
        Open a pending order to buy at a stop-limit price

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        current_price = self.data.get_latest_bar_value(symbol, 'close')
        if price <= current_price:
            raise ValueError(
                f"The stop price {price} must be greater than the current price {current_price}.")
        if price >= stoplimit:
            raise ValueError(
                f"The stop-limit price {stoplimit} must be greater than the price {price}.")
        order = SignalEvent(id, symbol, dtime, 'LONG',
                            quantity=quantity, strength=strength, price=price, stoplimit=stoplimit)
        self._orders[symbol]['BSTPLMT'].append(order)

    def sell_stop_limit(self, id, symbol, price, stoplimit, quantity, strength=1.0, dtime=None):
        """
        Open a pending order to sell at a stop-limit price

        See `bbstrader.btengine.event.SignalEvent` for more details on arguments.
        """
        current_price = self.data.get_latest_bar_value(symbol, 'close')
        if price >= current_price:
            raise ValueError(
                f"The stop price {price} must be less than the current price {current_price}.")
        if price <= stoplimit:
            raise ValueError(
                f"The stop-limit price {stoplimit} must be less than the price {price}.")
        order = SignalEvent(id, symbol, dtime, 'SHORT',
                            quantity=quantity, strength=strength, price=price, stoplimit=stoplimit)
        self._orders[symbol]['SSTPLMT'].append(order)

    def check_pending_orders(self):
        """
        Check for pending orders and handle them accordingly.
        """
        for symbol in self.symbols:
            dtime = self.data.get_latest_bar_datetime(symbol)
            logmsg = lambda order, type: self.logger.info(
                f"{type} ORDER EXECUTED: SYMBOL={symbol}, QUANTITY={order.quantity}, "
                f"PRICE @ {order.price}", custom_time=dtime)
            for order in self._orders[symbol]['BLMT'].copy():
                if self.data.get_latest_bar_value(symbol, 'close') <= order.price:
                    self.buy_mkt(order.strategy_id, symbol,
                             order.price, order.quantity, dtime)
                    try:
                        self._orders[symbol]['BLMT'].remove(order)
                        assert order not in self._orders[symbol]['BLMT']
                        logmsg(order, 'BUY LIMIT')
                    except AssertionError:
                        self._orders[symbol]['BLMT'] = [o for o in self._orders[symbol]['BLMT'] if o != order]
                        logmsg(order, 'BUY LIMIT')
            for order in self._orders[symbol]['SLMT'].copy():
                if self.data.get_latest_bar_value(symbol, 'close') >= order.price:
                    self.sell_mkt(order.strategy_id, symbol,
                              order.price, order.quantity, dtime)
                    try:
                        self._orders[symbol]['SLMT'].remove(order)
                        assert order not in self._orders[symbol]['SLMT']
                        logmsg(order, 'SELL LIMIT')
                    except AssertionError:
                        self._orders[symbol]['SLMT'] = [o for o in self._orders[symbol]['SLMT'] if o != order]
                        logmsg(order, 'SELL LIMIT')
            for order in self._orders[symbol]['BSTP'].copy():
                if self.data.get_latest_bar_value(symbol, 'close') >= order.price:
                    self.buy_mkt(order.strategy_id, symbol,
                             order.price, order.quantity, dtime)
                    try:
                        self._orders[symbol]['BSTP'].remove(order)
                        assert order not in self._orders[symbol]['BSTP']
                        logmsg(order, 'BUY STOP')
                    except AssertionError:
                        self._orders[symbol]['BSTP'] = [o for o in self._orders[symbol]['BSTP'] if o != order]
                        logmsg(order, 'BUY STOP')
            for order in self._orders[symbol]['SSTP'].copy():
                if self.data.get_latest_bar_value(symbol, 'close') <= order.price:
                    self.sell_mkt(order.strategy_id, symbol,
                              order.price, order.quantity, dtime)
                    try:
                        self._orders[symbol]['SSTP'].remove(order)
                        assert order not in self._orders[symbol]['SSTP']
                        logmsg(order, 'SELL STOP')
                    except AssertionError:
                        self._orders[symbol]['SSTP'] = [o for o in self._orders[symbol]['SSTP'] if o != order]
                        logmsg(order, 'SELL STOP')
            for order in self._orders[symbol]['BSTPLMT'].copy():
                if self.data.get_latest_bar_value(symbol, 'close') >= order.price:
                    self.buy_limit(order.strategy_id, symbol,
                                   order.stoplimit, order.quantity, dtime)
                    try:
                        self._orders[symbol]['BSTPLMT'].remove(order)
                        assert order not in self._orders[symbol]['BSTPLMT']
                        logmsg(order, 'BUY STOP LIMIT')
                    except AssertionError:
                        self._orders[symbol]['BSTPLMT'] = [o for o in self._orders[symbol]['BSTPLMT'] if o != order]
                        logmsg(order, 'BUY STOP LIMIT')
            for order in self._orders[symbol]['SSTPLMT'].copy():
                if self.data.get_latest_bar_value(symbol, 'close') <= order.price:
                    self.sell_limit(order.strategy_id, symbol,
                                    order.stoplimit, order.quantity, dtime)
                    try:
                        self._orders[symbol]['SSTPLMT'].remove(order)
                        assert order not in self._orders[symbol]['SSTPLMT']
                        logmsg(order, 'SELL STOP LIMIT')
                    except AssertionError:
                        self._orders[symbol]['SSTPLMT'] = [o for o in self._orders[symbol]['SSTPLMT'] if o != order]
                        logmsg(order, 'SELL STOP LIMIT')

    def calculate_pct_change(self, current_price, lh_price):
        return ((current_price - lh_price) / lh_price) * 100
    
    def get_asset_values(self,
                          symbol_list: List[str],
                          window: int,
                          value_type: str = 'returns',
                          array: bool = True,
                          bars: DataHandler = None,
                          mode: Literal['backtest', 'live'] = 'backtest',
                          tf: str = 'D1'
                          ) -> Dict[str, np.ndarray | pd.Series] | None:
        """
        Get the historical OHLCV value or returns or custum value 
        based on the DataHandker of the assets in the symbol list.

        Args:
            bars : DataHandler for market data handling, required for backtest mode.
            symbol_list : List of ticker symbols for the pairs trading strategy.
            value_type : The type of value to get (e.g., returns, open, high, low, close, adjclose, volume).
            array : If True, return the values as numpy arrays, otherwise as pandas Series.
            mode : Mode of operation for the strategy.
            window : The lookback period for resquesting the data.
            tf : The time frame for the strategy.

        Returns:
            asset_values : Historical values of the assets in the symbol list.
        
        Note:
            In Live mode, the `bbstrader.metatrader.rates.Rates` class is used to get the historical data
            so the value_type must be 'returns', 'open', 'high', 'low', 'close', 'adjclose', 'volume'.
        """
        if mode not in ['backtest', 'live']:
            raise ValueError('Mode must be either backtest or live.')
        asset_values = {}
        if mode == 'backtest':
            if bars is None:
                raise ValueError('DataHandler is required for backtest mode.')
            for asset in symbol_list:
                if array:
                    values = bars.get_latest_bars_values(
                        asset, value_type, N=window)
                    asset_values[asset] = values[~np.isnan(values)]
                else:
                    values = bars.get_latest_bars(asset, N=window)
                    asset_values[asset] = getattr(values, value_type)    
        elif mode == 'live':
            for asset in symbol_list:
                rates = Rates(asset, timeframe=tf, count=window + 1, **self.kwargs)
                if array:
                    values = getattr(rates, value_type).values
                    asset_values[asset] = values[~np.isnan(values)]
                else:
                    values = getattr(rates, value_type)
                    asset_values[asset] = values
        if all(len(values) >= window for values in asset_values.values()):
            return {a: v[-window:] for a, v in asset_values.items()}
        else:
            return None

    def is_signal_time(self, period_count, signal_inverval) -> bool:
        """
        Check if we can generate a signal based on the current period count.
        We use the signal interval as a form of periodicity or rebalancing period.

        Args:
            period_count : The current period count (e.g., number of bars).
            signal_inverval : The signal interval for generating signals (e.g., every 5 bars).

        Returns:
            bool : True if we can generate a signal, False otherwise
        """
        if period_count == 0 or period_count is None:
            return True
        return period_count % signal_inverval == 0

    def ispositions(self, symbol, strategy_id, position, max_trades, one_true=False, account=None) -> bool:
        """
        This function is use for live trading to check if there are open positions
        for a given symbol and strategy. It is used to prevent opening more trades
        than the maximum allowed trades per symbol.

        Args:
            symbol : The symbol for the trade.
            strategy_id : The unique identifier for the strategy.
            position : The position type (1: short, 0: long).
            max_trades : The maximum number of trades allowed per symbol.
            one_true : If True, return True if there is at least one open position.
            account : The `bbstrader.metatrader.Account` object for the strategy.

        Returns:
            bool : True if there are open positions, False otherwise
        """
        account = account or Account(**self.kwargs)
        positions = account.get_positions(symbol=symbol)
        if positions is not None:
            open_positions = [
                pos.ticket for pos in positions if pos.type == position
                and pos.magic == strategy_id
            ]
            if one_true:
                return len(open_positions) in range(1, max_trades + 1)
            return len(open_positions) >= max_trades
        return False

    def get_positions_prices(self, symbol, strategy_id, position, account=None):
        """
        Get the buy or sell prices for open positions of a given symbol and strategy.

        Args:
            symbol : The symbol for the trade.
            strategy_id : The unique identifier for the strategy.
            position : The position type (1: short, 0: long).
            account : The `bbstrader.metatrader.Account` object for the strategy.

        Returns:
            prices : numpy array of buy or sell prices for open positions if any or an empty array.
        """
        account = account or Account(**self.kwargs)
        positions = account.get_positions(symbol=symbol)
        if positions is not None:
            prices = np.array([
                pos.price_open for pos in positions
                if pos.type == position and pos.magic == strategy_id
            ])
            return prices
        return np.array([])

    def get_current_dt(self, time_zone: str = 'US/Eastern') -> datetime:
        return datetime.now(pytz.timezone(time_zone))

    def convert_time_zone(self, dt: datetime | int | pd.Timestamp,
                          from_tz: str = 'UTC',
                          to_tz: str = 'US/Eastern'
                          ) -> pd.Timestamp:
        """
        Convert datetime from one timezone to another.

        Args:
            dt : The datetime to convert.
            from_tz : The timezone to convert from.
            to_tz : The timezone to convert to.

        Returns:
            dt_to : The converted datetime.
        """
        from_tz = pytz.timezone(from_tz)
        if isinstance(dt, datetime):
            dt = pd.to_datetime(dt, unit='s')
        elif isinstance(dt, int):
            dt = pd.to_datetime(dt, unit='s')
        if dt.tzinfo is None:
            dt = dt.tz_localize(from_tz)
        else:
            dt = dt.tz_convert(from_tz)

        dt_to = dt.tz_convert(pytz.timezone(to_tz))
        return dt_to


class TWSStrategy(Strategy):
    ...
